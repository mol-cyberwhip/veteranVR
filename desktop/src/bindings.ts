
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async backendReadyState() : Promise<Result<BackendReadyState, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_ready_state") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendRecover() : Promise<Result<BackendReadyState, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_recover") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async shutdownBackend() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("shutdown_backend") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendGetSettings() : Promise<Result<SettingsResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_get_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendUpdateSettings(patch: JsonValue) : Promise<Result<SettingsResponse, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_update_settings", { patch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendCatalogStatus() : Promise<Result<CatalogStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_catalog_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendCatalogLoadCache() : Promise<Result<CatalogLoadCacheResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_catalog_load_cache") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendCatalogSync(force: boolean | null) : Promise<Result<CatalogSyncResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_catalog_sync", { force }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendCatalogSearch(query: string | null, limit: number | null, offset: number | null) : Promise<Result<CatalogSearchResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_catalog_search", { query, limit, offset }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async searchYoutubeTrailer(gameName: string) : Promise<Result<string | null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search_youtube_trailer", { gameName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendCatalogGameDetail(packageName: string) : Promise<Result<CatalogGameDetail, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_catalog_game_detail", { packageName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendCatalogGameVersions(packageName: string) : Promise<Result<CatalogGameVersions, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_catalog_game_versions", { packageName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendCatalogThumbnailPath(packageName: string) : Promise<Result<CatalogThumbnailPath, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_catalog_thumbnail_path", { packageName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendCatalogNote(packageName: string) : Promise<Result<CatalogNote, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_catalog_note", { packageName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendCatalogLibrary(query: string | null, sortBy: string | null, sortAscending: boolean | null, filter: string | null, limit: number | null, offset: number | null) : Promise<Result<LibraryResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_catalog_library", { query, sortBy, sortAscending, filter, limit, offset }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendFavoritesToggle(packageName: string) : Promise<Result<FavoritesToggleResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_favorites_toggle", { packageName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDownloadQueueStatus() : Promise<Result<DownloadQueueStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_download_queue_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDownloadQueueAdd(packageName: string, releaseName: string | null) : Promise<Result<DownloadQueueAddResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_download_queue_add", { packageName, releaseName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDownloadQueueRemove(packageName: string) : Promise<Result<DownloadQueueStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_download_queue_remove", { packageName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDownloadQueueReorder(packageName: string, position: number) : Promise<Result<DownloadQueueStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_download_queue_reorder", { packageName, position }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDownloadStartProcessing() : Promise<Result<DownloadStartResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_download_start_processing") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDownloadCancel(packageName: string | null) : Promise<Result<DownloadCancelResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_download_cancel", { packageName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDownloadRetry(packageName: string, releaseName: string | null) : Promise<Result<DownloadQueueAddResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_download_retry", { packageName, releaseName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDownloadPause() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_download_pause") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDownloadResume() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_download_resume") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDownloadSetBandwidth(mbps: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_download_set_bandwidth", { mbps }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDownloadLocationGet() : Promise<Result<DownloadLocation, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_download_location_get") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDownloadLocationSet(path: string) : Promise<Result<DownloadLocation, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_download_location_set", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDownloadListLocal() : Promise<Result<DownloadListLocalResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_download_list_local") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDownloadCheckLocal(packageName: string, releaseName: string | null) : Promise<Result<DownloadCheckLocalResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_download_check_local", { packageName, releaseName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDownloadOpenFolder(packageName: string | null) : Promise<Result<DownloadOpenFolderResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_download_open_folder", { packageName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDownloadDeleteFiles(packageName: string) : Promise<Result<DownloadDeleteResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_download_delete_files", { packageName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendInstallGame(packageName: string, releaseName: string | null) : Promise<Result<InstallGameResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_install_game", { packageName, releaseName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendInstallStatus() : Promise<Result<InstallStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_install_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendInstallCancel() : Promise<Result<InstallCancelResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_install_cancel") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendUninstallGame(packageName: string, keepObb: boolean | null, keepData: boolean | null) : Promise<Result<UninstallResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_uninstall_game", { packageName, keepObb, keepData }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendInstalledApps() : Promise<Result<InstalledAppsResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_installed_apps") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendInstalledAppVersion(packageName: string) : Promise<Result<AppVersionResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_installed_app_version", { packageName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendInstallLocal(path: string) : Promise<Result<InstallLocalResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_install_local", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDeviceState() : Promise<Result<DeviceState, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_device_state") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendSelectDevice(serial: string) : Promise<Result<DeviceState, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_select_device", { serial }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendClearDeviceSelection() : Promise<Result<DeviceState, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_clear_device_selection") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendWirelessConnect(endpoint: string | null, saveEndpoint: boolean | null) : Promise<Result<WirelessConnectResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_wireless_connect", { endpoint, saveEndpoint }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendWirelessDisconnect(endpoint: string | null) : Promise<Result<WirelessDisconnectResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_wireless_disconnect", { endpoint }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendWirelessReconnect() : Promise<Result<WirelessReconnectResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_wireless_reconnect") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async pollBackendEvents(operationId: string | null, limit: number | null) : Promise<Result<JsonValue, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("poll_backend_events", { operationId, limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async frontendLog(level: string, message: string) : Promise<void> {
    await TAURI_INVOKE("frontend_log", { level, message });
},
async backendLogEntries() : Promise<Result<LogEntriesResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_log_entries") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendLogExport() : Promise<Result<LogExportResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_log_export") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendLogReset() : Promise<Result<LogResetResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_log_reset") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendLogUploadPayload() : Promise<Result<LogUploadPayload, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_log_upload_payload") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendWindowStateGet() : Promise<Result<WindowState, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_window_state_get") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendWindowStateSet(patch: JsonValue) : Promise<Result<WindowStateSetResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_window_state_set", { patch }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async startBackendOperation() : Promise<Result<OperationStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_backend_operation") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendOperationStatus(operationId: string) : Promise<Result<OperationStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_operation_status", { operationId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cancelBackendOperation(operationId: string) : Promise<Result<OperationStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cancel_backend_operation", { operationId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDetectUpdates() : Promise<Result<DetectUpdatesResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_detect_updates") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendUpdateApp(packageName: string, releaseName: string | null) : Promise<Result<UpdateAppResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_update_app", { packageName, releaseName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendBackupApp(packageName: string) : Promise<Result<BackupAppResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_backup_app", { packageName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendRestoreApp(packageName: string) : Promise<Result<RestoreAppResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_restore_app", { packageName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendBulkBackup(packageNames: string[]) : Promise<Result<BulkBackupResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_bulk_backup", { packageNames }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendBulkRestore(backupPaths: string[]) : Promise<Result<BulkRestoreResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_bulk_restore", { backupPaths }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendExtractApk(packageName: string) : Promise<Result<OperationResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_extract_apk", { packageName }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendListBackups() : Promise<Result<ListBackupsResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_list_backups") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDeleteBackup(backupPath: string) : Promise<Result<DeleteBackupResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_delete_backup", { backupPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendMediaList() : Promise<Result<MediaListResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_media_list") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendMediaTransfer(sourcePath: string, destinationPath: string) : Promise<Result<MediaTransferResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_media_transfer", { sourcePath, destinationPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendPerformanceProfileGet() : Promise<Result<PerformanceProfileResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_performance_profile_get") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendPerformanceProfileSet(profile: PerformanceProfile) : Promise<Result<PerformanceProfileSetResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_performance_profile_set", { profile }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendAdbConsoleExecute(command: string) : Promise<Result<AdbConsoleExecuteResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_adb_console_execute", { command }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendAdbConsoleHistory() : Promise<Result<AdbConsoleHistoryResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_adb_console_history") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendNewAppsDiscovery() : Promise<Result<NewAppsDiscoveryResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_new_apps_discovery") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendDonationMetadataBuild() : Promise<Result<DonationMetadataResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_donation_metadata_build") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendPrivacyStatus() : Promise<Result<PrivacyStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_privacy_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendPrivacyUuidRotate() : Promise<Result<PrivacyUuidRotateResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_privacy_uuid_rotate") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendPrivacyTempCleanup() : Promise<Result<PrivacyTempCleanupResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_privacy_temp_cleanup") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendOfflineModeGet() : Promise<Result<OfflineModeStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_offline_mode_get") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendOfflineModeSet(enabled: boolean) : Promise<Result<OfflineModeSetResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_offline_mode_set", { enabled }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendCrashCheck() : Promise<Result<CrashInfo, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_crash_check") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendCrashReport(crashId: string) : Promise<Result<CrashReportResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_crash_report", { crashId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backendCrashDismiss(crashId: string) : Promise<Result<CrashDismissResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backend_crash_dismiss", { crashId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AdbConsoleExecuteResult = { success: boolean; output: string; exit_code: number }
export type AdbConsoleHistoryResult = { commands: string[] }
export type AppVersionResult = { version_code: string; version_name: string }
export type BackendReadyState = { ready: boolean; pid: number | null; version?: string | null }
export type BackendRecoverResult = { recovered: boolean; message?: string | null }
export type BackupAppResult = { operation_id: string; package_name: string }
export type BackupInfo = { package_name: string; backup_path: string; size_bytes: number; created_at: number }
export type BulkBackupResult = { operation_id: string; app_count: number }
export type BulkRestoreResult = { operation_id: string; backup_count: number }
/**
 * Full game details (used when fetching single game)
 */
export type CatalogGameDetail = { game_name: string; release_name: string; package_name: string; version_code: string; version_name: string; size: string; last_updated: string; downloads: string; release_apk_path: string; thumbnail_path: string; thumbnail_exists: boolean; note_path: string; note_excerpt: string; note_exists: boolean }
export type CatalogGameVersions = { games: CatalogSearchGame[] }
export type CatalogLoadCacheResult = { loaded: boolean; status: CatalogStatus }
export type CatalogNote = { note: string }
/**
 * A game in catalog search results (condensed view)
 */
export type CatalogSearchGame = { package_name: string; release_name: string; game_name: string; version_code: string; version_name: string; size: string; last_updated: string; downloads: string }
export type CatalogSearchResult = { games: CatalogSearchGame[]; total: number; offset: number; limit: number; query: string }
export type CatalogStatus = { synced: boolean; source: string; game_count: number; has_config: boolean; config_base_uri?: string | null; sync_error?: string | null; thumbnails_dir: string; notes_dir: string; cache_dir: string; cache_age_hours?: number | null; cache_stale?: boolean | null; sync_in_progress: boolean }
export type CatalogSyncResult = { synced: boolean; status: CatalogStatus }
export type CatalogThumbnailPath = { thumbnail_path: string; thumbnail_exists: boolean }
export type CrashDismissResult = { dismissed: boolean }
export type CrashInfo = { has_crash: boolean; crash_id: string | null; timestamp: number | null; error_message: string | null }
export type CrashReportResult = { reported: boolean; report_id: string | null }
export type DeleteBackupResult = { deleted: boolean; backup_path: string }
export type DetectUpdatesResult = { has_updates: boolean; updates: UpdateInfo[]; count: number }
export type DeviceBattery = { level_percent: number | null; status: string; is_charging: boolean; temperature_c: number | null }
export type DeviceClearSelectionResult = { cleared: boolean }
export type DeviceInfo = { serial: string; state: string; model: string; product: string; is_selected: boolean; is_connected: boolean }
export type DeviceKeepAwake = { enabled: boolean; interval_seconds: number; active_count: number; active_operation_ids: string[] }
export type DeviceSelectResult = { selected: boolean; serial: string; device_state: DeviceState }
export type DeviceState = { status: string; status_message: string; troubleshooting: string; can_download: boolean; can_install: boolean; download_only_mode: boolean; selected_serial: string | null; selection_source: string; devices: DeviceInfo[]; storage: DeviceStorage | null; battery: DeviceBattery | null; wireless: DeviceWirelessState; keep_awake: DeviceKeepAwake }
export type DeviceStorage = { total_mb: number; used_mb: number; free_mb: number }
export type DeviceWirelessState = { saved_endpoint: string | null; auto_reconnect_enabled: boolean; last_endpoint: string | null; last_status: string | null; last_error: string | null; last_attempt_at: number | null }
export type DonationMetadata = { donation_url: string; qr_code_data: string }
export type DonationMetadataResult = { metadata: DonationMetadata }
export type DownloadCancelResult = { cancelled: boolean }
export type DownloadCheckLocalResult = { package_name: string; has_local_files: boolean; local_size_bytes: number }
export type DownloadDeleteResult = { deleted: boolean; freed_bytes: number }
export type DownloadListLocalResult = { files: LocalDownloadFile[]; count: number }
export type DownloadLocation = { download_dir: string; path: string; exists: boolean; free_bytes: number; file_count: number }
export type DownloadOpenFolderResult = { opened: boolean }
export type DownloadQueueAddResult = { added: boolean; retried: boolean; package_name: string; queue_length: number; reason?: string | null }
export type DownloadQueueItem = { package_name: string; release_name: string; game_name?: string | null; status: string; progress_percent: number; speed: string; eta: string; bytes_transferred: number; total_bytes: number; retry_count?: number | null; error?: string | null }
export type DownloadQueueRemoveResult = { removed: boolean; package_name: string }
export type DownloadQueueStatus = { queue: DownloadQueueItem[]; queued_count: number; total_count: number; processing: boolean; active_download?: DownloadQueueItem | null }
export type DownloadRetryResult = { retried: boolean }
export type DownloadStartResult = { started: boolean }
export type FavoritesToggleResult = { package_name: string; is_favorite: boolean; favorites: string[] }
export type Game = { game_name: string; release_name: string; package_name: string; version_code: string; release_apk_path: string; version_name: string; downloads: string; size: string; last_updated: string; thumbnail_path: string; thumbnail_exists: boolean; note_path: string; note_excerpt: string; note_exists: boolean; popularity_rank: number; is_new: boolean }
export type InstallCancelResult = { cancelled: boolean }
export type InstallGameResult = { operation_id: string; package_name: string }
export type InstallLocalResult = { success: boolean; message: string }
export type InstallStatus = { is_installing: boolean; current_package: string | null; progress_percent: number; status_message: string }
export type InstalledApp = { package_name: string; app_name: string; version_code: string; version_name: string; is_system_app: boolean; install_time: number | null; last_update_time: number | null; in_catalog: boolean; game_name: string | null; catalog_version_code: string | null; installed_version_code: string | null; size: string | null; update_available: boolean }
export type InstalledAppsResult = { apps: InstalledApp[]; count: number; has_updates: boolean }
export type JsonValue = null | boolean | number | string | JsonValue[] | Partial<{ [key in string]: JsonValue }>
/**
 * A game in the library view (with UI-specific fields)
 */
export type LibraryGame = { package_name: string; release_name: string; game_name: string; size: string; last_updated: string; version_code: string; downloads: string; is_favorite: boolean; is_new: boolean; popularity_rank: number; is_downloaded: boolean }
export type LibraryResult = { games: LibraryGame[]; total: number; offset: number; limit: number; query: string; sort_by: string; sort_ascending: boolean; filter: string; favorites_count: number }
export type ListBackupsResult = { backups: BackupInfo[] }
export type LocalDownloadFile = { name: string; package_name: string; size_bytes: number; modified_at: number | null }
export type LogEntriesResult = { entries: LogEntry[] }
export type LogEntry = { timestamp: number; level: string; message: string; source: string }
export type LogExportResult = { exported: boolean; path: string | null }
export type LogResetResult = { reset: boolean }
export type LogUploadPayload = { payload: string }
export type MediaFile = { name: string; path: string; size_bytes: number; mime_type: string }
export type MediaListResult = { files: MediaFile[]; total_size: number }
export type MediaTransferResult = { transferred: boolean; bytes_transferred: number; destination_path: string }
export type NewAppInfo = { package_name: string; app_name: string; install_date: number }
export type NewAppsDiscoveryResult = { new_apps: NewAppInfo[]; count: number }
export type OfflineModeSetResult = { enabled: boolean }
export type OfflineModeStatus = { enabled: boolean; last_sync_at: number | null; cache_valid: boolean }
export type OperationKeepAwake = { enabled: boolean; interval_seconds: number; ticks_sent: number; last_sent_at: number | null }
export type OperationProgress = { percent: number; completed_steps: number; total_steps: number }
/**
 * Generic success/error response for simple operations
 */
export type OperationResult = { success: boolean; message?: string | null }
export type OperationStateHistoryEntry = { version: number; state: string; entered_at: number; reason: string }
export type OperationStatus = { operation_id: string; operation: string; state: string; state_version: number; state_history: OperationStateHistoryEntry[]; progress: OperationProgress; cancel_requested: boolean; cancel_requested_at: number | null; terminal: boolean; terminal_at: number | null; keep_awake: OperationKeepAwake | null }
export type PerformanceProfile = { profile_name: string; cpu_limit_percent: number; memory_limit_mb: number; priority: string }
export type PerformanceProfileResult = { profile: PerformanceProfile }
export type PerformanceProfileSetResult = { saved: boolean }
export type PrivacyStatus = { uuid: string; temp_dir_size_bytes: number; can_cleanup: boolean }
export type PrivacyTempCleanupResult = { cleaned: boolean; freed_bytes: number }
export type PrivacyUuidRotateResult = { rotated: boolean; new_uuid: string }
export type PublicConfig = { base_uri: string; password: string }
export type RestoreAppResult = { operation_id: string; package_name: string }
export type Settings = { download_dir: string; delete_after_install: boolean; bandwidth_limit_mbps: number; ip_address: string; wireless_adb: boolean; favorited_games: string[]; use_gallery_view: boolean; sort_column: number; sort_ascending: boolean; queued_games: string[]; keep_awake_during_long_ops: boolean; keep_awake_interval_seconds: number; first_run: boolean; offline_mode: boolean; window_width: number; window_height: number; window_x: number; window_y: number; window_maximized: boolean; diagnostics_uuid: string; known_catalog_packages: string[]; performance_refresh_rate_hz: number; performance_cpu_level: number; performance_gpu_level: number; performance_texture_size: number }
export type SettingsResponse = { download_dir: string; auto_install: boolean; auto_backup: boolean; backup_dir: string; theme: string; language: string; enable_notifications: boolean; concurrent_downloads: number; favorited_games: string[]; wireless_auto_reconnect: boolean }
export type SettingsUpdateResponse = { updated: boolean; settings: SettingsResponse }
export type UninstallResult = { uninstalled: boolean; package_name: string; message: string | null }
export type UpdateAppResult = { operation_id: string; package_name: string }
export type UpdateInfo = { package_name: string; current_version: string; available_version: string; update_size: string }
export type WindowState = { width: number; height: number; x: number; y: number; maximized: boolean }
export type WindowStateResult = { state: WindowState }
export type WindowStateSetResult = { saved: boolean }
export type WirelessConnectResult = { connected: boolean; endpoint: string; message: string }
export type WirelessDisconnectResult = { disconnected: boolean; message: string }
export type WirelessReconnectResult = { reconnected: boolean; endpoint: string | null; message: string }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
